<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite errors="0" failures="1" hostname="WongBen" name="pytest" skipped="0" tests="2" time="16.942" timestamp="2020-08-21T23:16:14.844170"><testcase classname="test_dir.test_baidu1.TestSearch" file="test_dir\test_baidu1.py" line="28" name="test_baidu_search_case2" time="6.983"></testcase><testcase classname="test_dir.test_baidu1" file="conftest.py" line="127" name="test_fix_1" time="7.284"><failure message="configparser.NoOptionError: No option &apos;stg1&apos; in section: &apos;stg1&apos;">self = &lt;configparser.ConfigParser object at 0x000001D4493832B0&gt;
section = &apos;stg1&apos;, option = &apos;stg1&apos;

    def get(self, section, option, *, raw=False, vars=None, fallback=_UNSET):
        &quot;&quot;&quot;Get an option value for a given section.
    
        If `vars&apos; is provided, it must be a dictionary. The option is looked up
        in `vars&apos; (if provided), `section&apos;, and in `DEFAULTSECT&apos; in that order.
        If the key is not found and `fallback&apos; is provided, it is used as
        a fallback value. `None&apos; can be provided as a `fallback&apos; value.
    
        If interpolation is enabled and the optional argument `raw&apos; is False,
        all interpolations are expanded in the return values.
    
        Arguments `raw&apos;, `vars&apos;, and `fallback&apos; are keyword only.
    
        The section DEFAULT is special.
        &quot;&quot;&quot;
        try:
            d = self._unify_values(section, vars)
        except NoSectionError:
            if fallback is _UNSET:
                raise
            else:
                return fallback
        option = self.optionxform(option)
        try:
&gt;           value = d[option]

C:\ProgramData\Anaconda3\envs\AutoTest\lib\configparser.py:789: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = ChainMap({}, OrderedDict([(&apos;db_host&apos;, &apos;127.0.0.1&apos;), (&apos;db_port&apos;, &apos;69&apos;), (&apos;db_user&apos;, &apos;root&apos;), (&apos;db_pass&apos;, &apos;root&apos;), (&apos;host_port&apos;, &apos;69&apos;)]), OrderedDict())
key = &apos;stg1&apos;

    def __getitem__(self, key):
        for mapping in self.maps:
            try:
                return mapping[key]             # can&apos;t use &apos;key in mapping&apos; with defaultdict
            except KeyError:
                pass
&gt;       return self.__missing__(key)            # support subclasses that define __missing__

C:\ProgramData\Anaconda3\envs\AutoTest\lib\collections\__init__.py:883: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = ChainMap({}, OrderedDict([(&apos;db_host&apos;, &apos;127.0.0.1&apos;), (&apos;db_port&apos;, &apos;69&apos;), (&apos;db_user&apos;, &apos;root&apos;), (&apos;db_pass&apos;, &apos;root&apos;), (&apos;host_port&apos;, &apos;69&apos;)]), OrderedDict())
key = &apos;stg1&apos;

    def __missing__(self, key):
&gt;       raise KeyError(key)
E       KeyError: &apos;stg1&apos;

C:\ProgramData\Anaconda3\envs\AutoTest\lib\collections\__init__.py:875: KeyError

During handling of the above exception, another exception occurred:

cmdopt = &apos;stg1&apos;

    def test_fix_1(cmdopt):
        cfg = configparser.ConfigParser()
        cfg.read(&apos;config.ini&apos;, encoding=&apos;utf-8&apos;)
        print(&apos;cmdopt值为：&apos;, cmdopt)
&gt;       env = cfg.get(&apos;stg1&apos;, cmdopt)

conftest.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;configparser.ConfigParser object at 0x000001D4493832B0&gt;
section = &apos;stg1&apos;, option = &apos;stg1&apos;

    def get(self, section, option, *, raw=False, vars=None, fallback=_UNSET):
        &quot;&quot;&quot;Get an option value for a given section.
    
        If `vars&apos; is provided, it must be a dictionary. The option is looked up
        in `vars&apos; (if provided), `section&apos;, and in `DEFAULTSECT&apos; in that order.
        If the key is not found and `fallback&apos; is provided, it is used as
        a fallback value. `None&apos; can be provided as a `fallback&apos; value.
    
        If interpolation is enabled and the optional argument `raw&apos; is False,
        all interpolations are expanded in the return values.
    
        Arguments `raw&apos;, `vars&apos;, and `fallback&apos; are keyword only.
    
        The section DEFAULT is special.
        &quot;&quot;&quot;
        try:
            d = self._unify_values(section, vars)
        except NoSectionError:
            if fallback is _UNSET:
                raise
            else:
                return fallback
        option = self.optionxform(option)
        try:
            value = d[option]
        except KeyError:
            if fallback is _UNSET:
&gt;               raise NoOptionError(option, section)
E               configparser.NoOptionError: No option &apos;stg1&apos; in section: &apos;stg1&apos;

C:\ProgramData\Anaconda3\envs\AutoTest\lib\configparser.py:792: NoOptionError</failure></testcase></testsuite></testsuites>